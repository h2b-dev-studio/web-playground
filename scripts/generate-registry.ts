/**
 * Registry Generation Script
 *
 * Scans packages/ directory and generates a TypeScript registry file
 * for the entry landing page.
 *
 * @derives REQ-ENTRY-009
 *
 * Usage: tsx scripts/generate-registry.ts
 */
import * as fs from 'node:fs';
import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import type { PackageCard, PackageJson } from '../entry/src/types/index.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Converts a kebab-case package name to Title Case display name
 */
export function cleanPackageName(name: string): string {
  // Remove scope if present (e.g., @scope/package-name -> package-name)
  const unscoped = name.replace(/^@[^/]+\//, '');
  // Convert kebab-case to Title Case
  return unscoped
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Extracts package card metadata from package.json
 */
export function extractMetadata(packageJson: PackageJson, dirName: string): PackageCard {
  const playgroundMeta = packageJson.playgroundMeta;

  return {
    name: playgroundMeta?.title ?? cleanPackageName(packageJson.name),
    description: playgroundMeta?.description ?? packageJson.description ?? '',
    href: `${dirName}/index.html`,
  };
}

/**
 * Scans packages directory and returns sorted package metadata
 */
export function scanPackages(packagesDir: string): PackageCard[] {
  const entries = fs.readdirSync(packagesDir, { withFileTypes: true });
  const packages: PackageCard[] = [];

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const packageJsonPath = path.join(packagesDir, entry.name, 'package.json');

    if (!fs.existsSync(packageJsonPath)) continue;

    try {
      const content = fs.readFileSync(packageJsonPath, 'utf-8');
      const packageJson: PackageJson = JSON.parse(content);
      packages.push(extractMetadata(packageJson, entry.name));
    } catch {
      console.warn(`Warning: Failed to parse ${packageJsonPath}`);
    }
  }

  // Sort alphabetically by name
  return packages.sort((a, b) => a.name.localeCompare(b.name));
}

/**
 * Generates TypeScript content for the registry file
 */
export function generateRegistryContent(packages: readonly PackageCard[]): string {
  const packagesJson = packages
    .map((pkg) => {
      // Use JSON.stringify for proper escaping
      return `  {
    "name": ${JSON.stringify(pkg.name)},
    "description": ${JSON.stringify(pkg.description)},
    "href": ${JSON.stringify(pkg.href)}
  }`;
    })
    .join(',\n');

  return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-registry.ts
// @derives REQ-ENTRY-009

import type { PackageRegistry } from '../types/index.js';

export const packages: PackageRegistry = [
${packagesJson}
] as const;
`;
}

/**
 * Main entry point - generates registry from workspace packages
 */
function main() {
  const rootDir = path.resolve(__dirname, '..');
  const packagesDir = path.join(rootDir, 'packages');
  const outputDir = path.join(rootDir, 'entry', 'src', 'generated');
  const outputFile = path.join(outputDir, 'registry.ts');

  console.log('Scanning packages directory...');
  const packages = scanPackages(packagesDir);
  console.log(`Found ${packages.length} package(s)`);

  // Ensure output directory exists
  fs.mkdirSync(outputDir, { recursive: true });

  // Generate and write registry
  const content = generateRegistryContent(packages);
  fs.writeFileSync(outputFile, content, 'utf-8');

  console.log(`Generated ${outputFile}`);
  for (const pkg of packages) {
    console.log(`  - ${pkg.name}: ${pkg.href}`);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
